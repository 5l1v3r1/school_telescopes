<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Real Time Radio Astronomy Data</title>
    <script language="javascript" type="text/javascript" src="jquery.js"></script>
    <script language="javascript" type="text/javascript" src="jquery.flot.js"></script>
    <script language="javascript" type="text/javascript" src="jquery.flot.axislabels.js"></script>
    <script type="text/javascript">

    $(function() {
        var HOUR = 3600;
        var UPDATE = 2;
        var C = 299792.0;  // Speed of light in the void...
        
        var contData = [[], [], []];  // The continuum data
        var corrData = [[], []]; // Correlation Data
        var specData = [[], []];  // The spectral data
        var totalPoints = HOUR/UPDATE;  //number of Continuum points
        var scaling = 1;  // Scaling for continuum data
        var corrScaling = 1; // Scaling for correlation data
        var offset = 0;   // Offset for continuum data
        var contLabels = ["U", "U", "U"];
        var corrLabels = ["U", "U"];
        for (var i = 0; i < contData.length; i++)
        {
			for (var j = 0; j < totalPoints; j++)
			{
				contData[i][j] = 0.0;
			}
		}
		for (var i = 0; i < corrData.length; i++)
		{
			for (var j = 0; j < totalPoints; j++)
			{
				corrData[i][j] = 0.0;
			}
		}
		for (var i = 0; i < specData.length; i++)
		{
			for (var j = 0; j < 1024; j++)
			{
				specData[i][j] = -100.0
			}
		}
        
        /*
         * These can (and will) get updated during AJAX data loads
         */
        var frequency = 0.0;
        var bandwidth = 0.0;
        var fftsize = 1024;
        var dec = -90.0;
        var lmst = "00:00:00";
        var expname = "TESTING";
        var latitude = -90.0;
        var longitude = -180.0;
        var updated = "";
        
        
        /*
         * Place to record current baseline values
         *  and remember current baselining-state
         *  for spectral data.
         */
        var baseline_state = false;
        var baseline = [[], []];
        
        /*
         * Peak-hold buffer for spectral data
         */
        var peak = [];
        
        /*
         * Smart scaling control flag for spectral data
         */
        var smartscaling = false;
        
        /*
         * Doppler-based X axis tics for spectral plot
         */
        var doppler = false;
        
        /*
         * Spectral plot X axis label
         */
        var specXlabel = "Frequency (MHz)";
        
        /*
         * Peak hold mode state
         */
        var peakholdmode = false;
        
        var updateInterval = UPDATE*1000;
        
		 /*
		 * Need to make a record of the Spectral xaxis tic values
		 */
		var xaxis = [];

		/*
		 * Need to make a record of the (possibly baselined)
		 *  y2axis (Spectral) values
		 */
		var y2axis = [];
        
        function zeroFilled() {
            res = contData[0];
            return res;
        }
        
        function zeroSpectraFilled() {
            res = specData[0];
            return res;
        }
        
       $("#smartScale2").click(function() {

            var minv;
            var maxv;
            
            minv = Math.min.apply(null, y2axis[0]);
            maxv = Math.max.apply(null, y2axis[0]);
            smartscaling = true;
            if (baseline_state == false) {
				plot2.getOptions().yaxes[0].min = minv-2.5;
				plot2.getOptions().yaxes[0].max = maxv+2.5;
			}
			else {
				plot2.getOptions().yaxes[0].min = minv-0.25;
				plot2.getOptions().yaxes[0].max = maxv+0.25;
			}
            plot2.setupGrid();
            plot2.draw();
        });
        
        $("#smartScale2Reset").click(function() {
            smartscaling = false;
            if (baseline_state == false) {
				plot2.getOptions().yaxes[0].min = -80;
				plot2.getOptions().yaxes[0].max = -40;
			}
			else {
				plot2.getOptions().yaxes[0].min = -4;
				plot2.getOptions().yaxes[0].max = 4;
			}
			plot2.setupGrid();
			plot2.draw();
        });
        
        $("#showDoppler").change (function() {
            if ($(this).is(":checked")) {
                doppler = true
                specXlabel = "Doppler Velocity (km/sec)";
            }
            else {
                doppler = false
                specXlabel = "Frequency (MHz)";
            }
            plot2.getOptions().xaxes[0].axisLabel = specXlabel;
            plot2.setupGrid();
            plot2.draw();
        });
        
        $("#peakHold").change (function() {
            if ($(this).is(":checked")) {
                peakholdmode = true;
            }
            else {
                peakholdmode = false;
            }
        });
        
        $("#enableBaseline").change (function() {
            if ($(this).is(":checked")) {
                if (baseline_state == false) {
                    baseline_state = true;
                    baseline[0] = specData[0].slice();
                    baseline[1] = specData[1].slice();
                    if (smartscaling == false) {
                        plot2.getOptions().yaxes[0].min = -5;
                        plot2.getOptions().yaxes[0].max = 5;
                        plot2.setupGrid();
                        plot2.draw();
                    }
                }
            }
            else {
                baseline_state = false;
                baseline = [[], []];
                    if (smartscaling == false) {
                    plot2.getOptions().yaxes[0].min = -80;
                    plot2.getOptions().yaxes[0].max = -40;
                    plot2.setupGrid();
                    plot2.draw();
                }
            }
        });
        
        $("#scaling").val(scaling).change(function () {
            var v = $(this).val();
            if (v && !isNaN(+v)) {
                scaling = +v;
                if (scaling < 0.001) {
                    scaling = 0.001;
                } else if (scaling > 100000) {
                    scaling = 100000;
                }
                $(this).val("" + scaling);
            }
        });
        
        $("#corrScaling").val(scaling).change(function () {
            var v = $(this).val();
            if (v && !isNaN(+v)) {
                corrScaling = +v;
                if (corrScaling < 1) {
                    corrScaling = 1;
                } else if (corrScaling > 100000) {
                    corrScaling = 100000;
                }
                $(this).val("" + corrScaling);
            }
        });
        
        $("#offset").val(offset).change(function () {
            var v = $(this).val();
            offset = v;
            $(this).val("" + offset);
        });
        
        
        /*
         * The continuum Flot plot object
         */
        var plot = $.plot("#Continuum", [ zeroFilled() ], {
            series: {
                shadowSize: 0,  // Drawing is faster without shadows
                lines: {lineWidth: 1}
            },
            colors: ["blue", "red", "green", "purple"],
            axisLabels : {
                show: true
            },
                  xaxes: [{
            axisLabel: 'LMST Offset(Seconds)',
        }],
                 legend: {
				position: "ne"
			},
            yaxes: [{
                axisLabel: 'Detector',
                axisLabelPadding: 25
                }],
            xaxis: {
                show: true
            },
            yaxis : {
                min: 0,
                max: 1.0
            },
            grid: {
                backgroundColor : {colors : ["ivory", "Khaki"]},
                hoverable: true
                }
        });
        
        /*
         * The correlation Flot plot object
         */
        var plotCorr = $.plot("#Correlation", [ zeroFilled() ], {
            series: {
                shadowSize: 0,  // Drawing is faster without shadows
                lines: {lineWidth: 1}
            },
            colors: ["blue", "red", "green", "purple"],
            axisLabels : {
                show: true
            },
                  xaxes: [{
            axisLabel: 'LMST Offset(Seconds)',
        }],
                 legend: {
				position: "ne"
			},
            yaxes: [{
                axisLabel: 'Correlation',
                axisLabelPadding: 30
                }],
            xaxis: {
                show: true
            },
            yaxis : {
                min: -1.0,
                max: 1.0
            },
            grid: {
                backgroundColor : {colors : ["ivory", "Khaki"]},
                hoverable: true
                }
        });

        /*
         * The spectral Flot plot object
         */
        var plot2 = $.plot("#Spectral", [ zeroSpectraFilled() ], {
            series: {
                shadowSize: 0,
                lines: {lineWidth: 1}
            },
            colors: ["blue", "red", "green", "purple"],
            axisLabels : {
                show: true
            },
                  xaxes: [{
            axisLabel: 'Frequency (MHz)',
        }],
        legend : {
			position: "ne"
		},
            yaxes: [{
                axisLabel: 'Rel. Power(dB)',
                }],
            xaxis: {
                show: true
            },
            yaxis : {
                min: -80,
                max: -40
            },
            grid: {
                backgroundColor : {colors : ["ivory", "Khaki"]},
                hoverable: true
                }
        });
        
        /*
         * Hover functions for both Continuum and Spectral plots.
         */
        $("#Continuum").bind("plothover", function (event, pos, item) {
                var str = "(" + pos.x.toFixed(2) + "sec" + " " + pos.y.toFixed(2) + "units)";
                $("#ContinuumHover").text(str);
        });

        $("#Spectral").bind("plothover", function (event, pos, item) {
            var stype;
            if (doppler == true) {
                stype = "km/s";
            }
            else {
                stype = "MHz";
            }
            var str = "(" + pos.x.toFixed(2) + stype + " " + pos.y.toFixed(2) + "dB)";
            $("#SpectralHover").text(str);
        });
        
        /*
         * event functions for AJAX
         */
         
        /*
         * First for the Continuum data
         */
        function onFileData(thing) {
			for (var i = 0; i < contData.length; i++)
			{
				contData[i].unshift(thing.values[i]);
				contData[i].pop();
			}
			for (var i = 0; i < corrData.length; i++)
			{
				corrData[i].unshift(thing.values[i+3]);
				corrData[i].pop();
			}
			contLabels = thing.labels;
			corrLabels[0] = thing.labels[3];
			corrLabels[1] = thing.labels[4];
            expname = thing.expname;
            dec = thing.dec;
            lmst = thing.lmst;
            latitude = thing.latitude;
            longitude = thing.longitude;
            updated = thing.updated;
            $("#PageTitle").html("<h3>" + "Experiment: " + expname + " DEC: " + dec + " LMST: " + lmst + "</h3>");
            $("#Subtitle").html("<h4>" + "Latitude: " + latitude + " Longitude: " + longitude + " Updated: " + updated+"</h4>");
            
        }

        /*
         * For Spectral data
         */
        last_spec_data=[];
        function onSpecFileData(thing) {
            specData[0] = thing.Sky.slice();
            specData[1] = thing.Ref.slice();
            frequency = thing.frequency;
            bandwidth = thing.bandwidth;
            fftsize = thing.fftsize;
        }
        
        /*
         * This function is called to do plot updates every interval seconds
         */
        function update() {
            
            /*
             * First the Continuum data
             *
             * Fairly simple--apply scaling and offset and plot
             */
            var res = [];
            for (var i = 0; i < contData.length; ++i) {
				var cdat = [];
				for (var j = 0; j < totalPoints; j++) {
					cdat.push([j*(updateInterval/1000.0), (contData[i][j]*scaling)-offset]);
				}
				dic = {label : contLabels[i], data : cdat}
				res.push(dic);
            }
            plot.setData(res);
            
            /*
             * Next the Correlation data
             *
             * Fairly simple--apply scaling and offset and plot
             */
            var res = [];
            for (var i = 0; i < corrData.length; ++i) {
				var cdat = [];
				for (var j = 0; j < totalPoints; j++) {
					cdat.push([j*(updateInterval/1000.0), (corrData[i][j]*corrScaling)]);
				}
				dic = {label : corrLabels[i], data : cdat}
				res.push(dic);
            }
            plotCorr.setData(res);
            
            
            /*
             * Then the Spectral data
             * More complicated.  Have to deal with:
             *
             *   o Baseline subtraction
             *   o Doppler mode
             */
            var res2 = [];
            var res3 = [];
            
            /*
             * Fundamental parameters relating to frequency, so we can
             *  set tics on X axis appropriately.
             */
            var step  = bandwidth/fftsize;
            var start = frequency - (bandwidth/2);
            var end = frequency + (bandwidth/2);
            var v = 0;
            var v2 = 0;

			y2axis = [[],[]];
			xaxis = [];
            for (var i = 0; i < specData[0].length; ++i) {
                var x = 0;
                
                /*
                 * Deal with baselined data
                 */
                if (baseline_state == true) {
                    v = specData[0][i] - baseline[0][i];
                    v2 = specData[1][i]- baseline[1][i];
                }
                else {
                    v = specData[0][i];
                    v2 = specData[1][i];
                }
                y2axis[0].push(v);
                y2axis[1].push(v2);

                /*
                 * Current x-axis value
                 */
                x = start+(i*step);
                
                /*
                 * If doing just regular frequency...
                 */
                if (doppler != true) {
                    
                    /*
                     * xaxis record in MHz
                     */
                    xaxis.push(x/1000000.0);
                    res2.push([x/1000000.0, v]);
                    res3.push([x/1000000.0, v2]);
                }
                /*
                 * Doing doppler tics (km/sec)
                 */
                else {
                    var dv;
                    
                    /*
                     * x contains current frequency value
                     */
                    dv = x-frequency; // frequency offset from Fc
                    dv /= frequency; // as fraction of Fc
                    dv *= C  // Scaled to C in km/sec
                    
                    xaxis.push(dv);
                    res2.push([dv, v]);
                    res3.push([dv, v2]);
                }
            }
            
            /*
             * data length changed, reset our peak recorder
             *
             * peak is, like contData/specData, a persistent variable, since
             *  it has to record peak values over time.
             */
            if (peak.length != y2axis[0].length && (y2axis[0].length > 10)) {
                peak = y2axis[0].slice();
            }
            else {
                /*
                 * Check for new peak value at each position.
                 */
                for (var i = 0; i < peak.length; i++) {
                    if (y2axis[0][i] > peak[i]) {
                        peak[i] = y2axis[0][i];
                    }
                    if (y2axis[1][i] > peak[i]) {
						peak[i] = y2axis[1][i];
					}
                }
            }
            
            /*
             * If we're using peak hold mode, we need to create a 2nd
             *  dataset containing the peak-hold values.
             */
            if (peakholdmode == true) {
                var peaky = [];
                
                
                /*
                 * Build up our peaky dataset
                 */
                for (var i = 0; i < peak.length; i++) {
                    peaky.push([xaxis[i],peak[i]]);
                }
                /*
                 * Call the plotter
                 */
                
                dic1 = {label : "Peak", data: peaky};
                dic2 = {label : "Sky", data: res2};
                dic3 = {label : "Ref", data: res3};
                plot2.setData([dic2,dic3,dic1]);
            }
            /*
             * Just plot 'res2/res3' -- no peak hold dataset
             */
            else
            {
                peak = y2axis[0].slice();
                dic1 = {label : "Sky", data: res2};
                dic2 = {label : "Ref", data: res3};
                plot2.setData([dic1,dic2]);
            }

            /*
             * The label for the spectral plot X axis may have changed
             *   reset the grid on each plot.
             */
            plot2.getOptions().xaxes[0].axisLabel = specXlabel;
            plot2.setupGrid();

            /*
             * Finally draw the plots
             */
            plot.draw();
            plot2.draw();
            plotCorr.draw();
            
            /*
             * Schedule some AJAX data retrievals
             */
            $.ajax(
                {url: "astro_data/tpower.json",
                    type: "GET",
                dataType: "json",
                beforeSend: function(xhr){
                    if (xhr.overrideMimeType)
                    {
                      xhr.overrideMimeType("application/json");
                    }
                 },
                 success: onFileData}
                 );
            $.ajax(
                {url: "astro_data/spectral.json",
                    type: "GET",
                dataType: "json",
                beforeSend: function(xhr){
                    if (xhr.overrideMimeType)
                    {
                      xhr.overrideMimeType("application/json");
                    }
                 },
                 success: onSpecFileData}
                 );
            
            /*
             * Reschedule ourselves...
             */  
            setTimeout(update, updateInterval);
        }


            
        update();
        

    });

    </script>
</head>
<body bgcolor="LightGrey">

    <div id="PageTitle">
        <h3>Experiment</h3>
    </div>
    <div id="Subtitle">
        <h4>Subs</h4>
    </div>
    <div id="header">
        <h3>Continuum Data</h3>
    </div>

    <div id="Continuum" style="width:950px;height:300px"></div>

    <h4 id="ContinuumHover">POS</h4>

    <p>
        Continuum Data Scaling: <input id="scaling" type="text" value="1" style="text-align: right; width:5em">
        Offset: <input id="offset" type="text" value="0" style="text-align; right; width:5em">
    </p>
    
    <h3>Correlation Data</h3>
    <div id="Correlation" style="width:950px;height:300px"></div>
     <p>
        Correlation Data Scaling: <input id="corrScaling" type="text" value="1" style="text-align: right; width:5em">
    </p>
    <div id="header2">
        <h3>Spectral Data</h3>
    </div>
    
    <div id="Spectral" style="width:950px;height:300px"></div>

        <h4 id="SpectralHover">POS</h4>

    <p>
        Apply Baseline Subtraction<input id="enableBaseline" type="checkbox">
    Show Doppler<input id="showDoppler" type="checkbox">
    Peak Hold<input id="peakHold" type="checkbox">
    <button type="button" id="smartScale2">Smart Scale</button>
    <button type="button" id="smartScale2Reset">Reset Smart Scale</button>
    </p>
    
    <hr>
    <p><small>Flot: Copyright 2007-2014 IOLA and Ole Laursen</small></p>
</body></html>
